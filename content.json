{"meta":{"title":"Lorne的十九创作坊","subtitle":null,"description":null,"author":"Lorne","url":"http://19czf.com","root":"/"},"pages":[{"title":"","date":"2019-11-02T02:07:23.636Z","updated":"2019-11-02T02:07:23.636Z","comments":true,"path":"README.html","permalink":"http://19czf.com/README.html","excerpt":"","text":"19czf.github.ioLorne的十九创作坊"}],"posts":[{"title":"一步步写c++ server程序（1）---TCP服务端","slug":"一步步写c-server程序（1）-TCP服务端","date":"2019-11-02T03:13:45.000Z","updated":"2019-11-02T13:21:32.141Z","comments":false,"path":"2019/11/02/一步步写c-server程序（1）-TCP服务端/","link":"","permalink":"http://19czf.com/2019/11/02/一步步写c-server程序（1）-TCP服务端/","excerpt":"","text":"前言整个系列的文章目的是写一个MessageServer，用于进程间通信的。并制定一个网络协议可以不同设备之间不同进程之间通信。协议暂时命名为N19协议。 一个简单的TCPServer先写一个简单的TCP server，用Telnet作为客户端测试TCPServer.cpp:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;errno.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include&lt;unistd.h&gt;#define MAXLINE 1024#define SERVER_PORT 8888int main(int argc, char *argv[])&#123; int ret = -1; int port = SERVER_PORT; //默认端口 if( argc == 2) &#123; port = atoi(argv[1]);//可以配置第一个参数为端口 &#125; printf(\"Server port [%d]\\n\", port); int listen_fd = 0; listen_fd = socket(AF_INET, SOCK_STREAM, 0); //TCP if(listen_fd &lt; 0) &#123; printf(\"listen_fd = %d error:[%s]\\n\", listen_fd, strerror(errno)); return 0; &#125; struct sockaddr_in server_addr; memset(&amp;server_addr, 0, sizeof(struct sockaddr_in)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(port); ret = bind(listen_fd, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr_in)); if(ret &lt; 0) &#123; printf(\"ret = %d error:[%s]\\n\", ret, strerror(errno)); return 0; &#125; ret = listen(listen_fd, SOMAXCONN); if(ret &lt; 0) &#123; printf(\"ret = %d error:[%s]\\n\", ret, strerror(errno)); return 0; &#125; while(1) &#123; int connect_fd = 0; socklen_t addrlen = 0; struct sockaddr_in accept_addr; connect_fd = accept(listen_fd, (struct sockaddr *) &amp;accept_addr, &amp;addrlen); if( connect_fd &lt; 0) &#123; printf(\"accept error:[%s]\\n\", strerror(errno)); continue; &#125; char send_buff[MAXLINE] = &#123;0&#125;; snprintf(send_buff, MAXLINE, \"welcome,your address is [%s:%d]\\n\", inet_ntoa(accept_addr.sin_addr), accept_addr.sin_port); ret = write(connect_fd, send_buff, strlen(send_buff)); if( ret &lt; 0) &#123; printf(\"send error: %s\\n\", strerror(errno)); return 0; &#125; for(;;) &#123; char recv_buff[MAXLINE] = &#123;0&#125;; int buff_len = 0; buff_len = read(connect_fd, recv_buff, MAXLINE); recv_buff[buff_len] = '\\0'; if(strstr(recv_buff, \"bye\")) &#123; break; &#125; snprintf(send_buff, MAXLINE, \"you said:%s\", recv_buff); ret = write(connect_fd, send_buff, strlen(send_buff)); if( ret &lt; 0) &#123; printf(\"send error: %s\\n\", strerror(errno)); break; &#125; &#125; close(connect_fd); &#125; close(listen_fd); return 0;&#125; 编译运行： 12gcc -o TCPServer TCPServer.cpp./TCPServer 1234567891011lorne@DESKTOP-06O9LMV:/mnt/c/Users/Lorne$ telnet 127.0.0.1 8888Trying 127.0.0.1...Connected to 127.0.0.1.Escape character is '^]'.welcome,your address is [153.127.0.0:6210]asdayou said:asdaasdyou said:asdbye byeConnection closed by foreign host.","categories":[{"name":"技术笔记","slug":"技术笔记","permalink":"http://19czf.com/categories/技术笔记/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://19czf.com/tags/TCP/"},{"name":"server","slug":"server","permalink":"http://19czf.com/tags/server/"},{"name":"网络编程","slug":"网络编程","permalink":"http://19czf.com/tags/网络编程/"},{"name":"c++","slug":"c","permalink":"http://19czf.com/tags/c/"}]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2019-11-02T02:08:58.000Z","updated":"2019-11-02T02:43:41.237Z","comments":false,"path":"2019/11/02/hexo常用命令/","link":"","permalink":"http://19czf.com/2019/11/02/hexo常用命令/","excerpt":"","text":"记录一下hexo发表文章的过程，免得每次发表文章的时候都打开官网。 新建文章1hexo new \"post title with whitespace\" 选项 描述 -p 自定义新文章的路径 -r 如果存在同名文章，将其替换 -s 文章的 Slug，作为新文章的文件名和发布后的 URL 生成文件1hexo g 本地预览1hexo s 选项 描述 -p, –port 重设端口 -s, –static 只使用静态文件 -l, –log 启动日记记录，使用覆盖记录格式 发布1hexo d 提示错误： 1ERROR Deployer not found: git 解决办法： 1sudo npm install --save hexo-deployer-git 清除缓存1hexo clean","categories":[{"name":"常用工具","slug":"常用工具","permalink":"http://19czf.com/categories/常用工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://19czf.com/tags/工具/"},{"name":"HEXO","slug":"HEXO","permalink":"http://19czf.com/tags/HEXO/"}]},{"title":"GIT的常用命令记录","slug":"GIT的常用命令记录","date":"2019-10-13T08:58:01.000Z","updated":"2019-11-02T02:12:38.892Z","comments":false,"path":"2019/10/13/GIT的常用命令记录/","link":"","permalink":"http://19czf.com/2019/10/13/GIT的常用命令记录/","excerpt":"","text":"设置git用户信息，会在提交记录里面显示，跟授权账号密码没有关系12$ git config --global user.name &quot;Your Name Comes Here&quot;$ git config --global user.email &quot;you@yourdomain.example.com&quot; 创建仓库 就得到.git 一个空的仓库 那么当前路径为工作树1$ git init 增加忽略文件需要忽略比如编译产生的中间文件、本地环境配置问价等把忽略的文件名加到 .gitignore，这样git add . 就不会所有的都添加了1echo &quot;xxx.o&quot; &gt; .gitignore 提交1231、git add . 或者跟文件名2、git commit -m “xxxx” or git commit再填写信息3、git commit --amend修改提交信息 推送到远程1git push origin master 工程克隆123$ cp -R $WORK/.git /tmp/m2doc.git$ cd /tmp$ git clone m2doc.git m2doc-copy m2doc-copy 里面除了包含,git 之外还有文件 拉取远程代码1$ git clone http://xxxxxx.git -b 分支名（不写默认master） 查看历史记录123456git log 查看历史版本git show eef5e798e4f102fe76398fcd21da300159f161c 一般只用钱几个字符即可 如git show eef5e7git show HEAD显示当前分枝的细节$ git show HEAD^ # 查看 HEAD 的父版本更新细节$ git show HEAD^^ # 查看 HEAD 的祖父版本更新细节$ git show HEAD~4 # 查看 HEAD 的祖父之祖父的版本更新细节 提交代码相关操作1234567git status 查看修改的内容git checkout test1.c 恢复文件 如果已经git add如那就恢复到add之前，（或者commit）git status 先看一下add 中的文件 $ git add 改动的文件$ git commit$ git pull$ git push 查看远程库的信息1git remote -v 分支操作123456git brunch xxx 创建XXX分枝git brunch 查看分支git checkout XXX 切换分支git checkout master 切换主分支git merge XXX 合并分支git brunch -d xxx 删除分支 撤回push12git reset --hard 63e386a81741f9261cdcfc353b4822a11cc543f8git push origin master --force 增加远程仓库1git remote add 仓库名 路径链接 关于git resetreset用的不好，很容易出问题。正常情况我是能不用就不用的12345git reset HEAD 如果后面什么都不跟的话 就是上一次add 里面的全部撤销了 ，不会恢复文件内容，只是撤销addgit reset HEAD XXX/XXX/XXX.java 就是对某个文件进行撤销了，不会恢复文件内容 git reset HEAD test1.c ，不会恢复文件内容git reset 指定版本 不会改变文件内容，恢复到add之前的状态git reset --soft 指定版本 不会改变文件内容恢复到add 之后的状态","categories":[{"name":"常用工具","slug":"常用工具","permalink":"http://19czf.com/categories/常用工具/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"http://19czf.com/tags/GIT/"},{"name":"工具","slug":"工具","permalink":"http://19czf.com/tags/工具/"}]}]}